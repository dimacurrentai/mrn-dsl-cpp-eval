// NOTE(dkorolev): This is suboptimal, but it ensures the code builds just with `g++ src.cc`, w/o `-std=c++17`.
#define CURRENT_FOR_CPP14

#include <iostream>
#include <fstream>

#include "../current/bricks/dflags/dflags.h"
#include "../current/bricks/file/file.h"
#include "../current/typesystem/serialization/json.h"

#include "ir.h"

DEFINE_string(in, "", "The input file to parse the JSON of the IR from.");
DEFINE_string(name, "default", "The name to use for the autogenerated tests.");
DEFINE_string(out, "/dev/stdout", "The output file to dump the C++ code into.");

inline void GenerateTestCase(std::ostream& fo, MaroonTestCase const& test, std::string const& name, size_t idx) {
  if (idx == 1) {
    fo << "TEST(Maroon, " << name << ") {" << std::endl;
  } else {
    fo << "TEST(Maroon, " << name << "_" << idx << ") {" << std::endl;
  }
  struct GenerateTestCaseVisitor final {
    std::string const& name;
    std::ostream& fo;
    GenerateTestCaseVisitor(std::string const& name, std::ostream& fo) : name(name), fo(fo) {}
    void operator()(MaroonTestCaseRunFiber const& test) {
      fo << "  MaroonEngine<" << test.maroon << ", " << test.maroon << "::" << test.fiber << "> engine;" << std::endl;
      fo << "  auto const [output, error] = engine.run();" << std::endl;
      std::ostringstream oss;
      for (auto const& e : test.golden_output) {
        oss << e << std::endl;
      }
      fo << "  EXPECT_EQ(R\"\"\"(" << oss.str() << ")\"\"\", output);" << std::endl;
      fo << "  EXPECT_EQ(\"\", error);" << std::endl;
    }
    void operator()(MaroonTestCaseFiberShouldThrow const& test) {
      fo << "  MaroonEngine<" << test.maroon << ',' << test.maroon << "::" << test.fiber << "> engine;" << std::endl;
      fo << "  auto const [output, error] = engine.run();" << std::endl;
      fo << "  EXPECT_EQ(R\"\"\"(" << test.error << ")\"\"\", error);" << std::endl;
      fo << "  EXPECT_EQ(\"\", output);" << std::endl;
    }
  };
  GenerateTestCaseVisitor visitor(name, fo);
  test.Call(visitor);
  fo << '}' << std::endl;
}

constexpr static char const* const kVarsFunctionSignature = "(ImplEnv& env)";
constexpr static char const* const kStepFunctionSignature = "(ImplEnv& env, ImplResultCollector& result)";

int main(int argc, char** argv) {
  ParseDFlags(&argc, &argv);

  if (FLAGS_in.empty()) {
    std::cerr << "The `--in` parameter is required." << std::endl;
    std::exit(1);
  }

  std::ofstream fo(FLAGS_out);

  MaroonIRScenarios scenarios;
  try {
    using T = decltype(scenarios);
    scenarios = ParseJSON<T, JSONFormat::Minimalistic>(current::FileSystem::ReadFileAsString(FLAGS_in));
  } catch (current::Exception const&) {
    std::cerr << "Failed to read and parse the IR JSON from `" << FLAGS_in << "`." << std::endl;
    std::exit(1);
  }

  fo << "#pragma once" << std::endl;
  fo << std::endl;
  fo << "#define CURRENT_FOR_CPP14" << std::endl;
  fo << std::endl;
  fo << "#include \"../src/engine.h\"" << std::endl;

  for (auto const& [maroon_name, maroon] : scenarios.maroon) {
    fo << std::endl;
    fo << "struct " << maroon_name << " {" << std::endl;
    fo << "  constexpr static bool kIsMaroon = true;" << std::endl;
    fo << "  constexpr static char const* const kMaroonName = \"" << maroon_name << "\";" << std::endl;
    for (auto const& [fiber_name, fiber] : maroon.fibers) {
      fo << "  struct " << fiber_name << " {" << std::endl;
      fo << "    constexpr static bool kIsFiber = true;" << std::endl;
      fo << "    constexpr static char const* const kFiberName = \"" << fiber_name << "\";" << std::endl;
      struct StatementsRecursiveVisitor final {
        std::ostream& fo;
        std::vector<std::pair<size_t, size_t>> nvars;  // { # upon entering, # to be added on block entry }
        std::string fn_name = "\n#error \"`fn_name` unset.\"\n";
        std::vector<MaroonIRVar> local_vars;
        std::vector<MaroonIRVar> next_step_init_vars;

        StatementsRecursiveVisitor(std::ostream& fo) : fo(fo) {}

        void EnsureNoLocalVars() {
          if (!local_vars.empty()) {
            std::cerr << "Internal invariant failed: should have no local variables at this point." << std::endl;
            std::exit(1);
          }
        }

        void PrintHeader() {
          size_t const entry_vars = local_vars.size();
          size_t const declared_vars = next_step_init_vars.size();

          size_t const step_idx = nvars.size();
          nvars.push_back({entry_vars, declared_vars});

          // Declare the vars.
          fo << "    static void VARS_" << step_idx << kVarsFunctionSignature << "{ // " << fn_name << std::endl;
          fo << "      static_cast<void>(env);" << std::endl;
          for (auto const& var : next_step_init_vars) {
            fo << "      env.DeclareVar(" << local_vars.size() << ",\"" << var.name << "\"," << var.init << ");"
               << std::endl;
            local_vars.push_back(var);
          }
          next_step_init_vars.clear();
          fo << "    }" << std::endl;

          fo << "    static void IMPL_" << step_idx << kStepFunctionSignature << " {  // " << fn_name << std::endl;
          size_t tmp_idx = 0;
          // TODO(dkorolev): Different var types, not just names here.
          for (auto const& var : local_vars) {
            fo << "      auto& " << var.name << " = env.AccessVar(" << tmp_idx++ << ",\"" << var.name << "\");"
               << std::endl;
          }
          for (auto const& var : local_vars) {
            fo << "      static_cast<void>(" << var.name << ");" << std::endl;
          }
          fo << "      ";
        }

        void PrintFooter() { fo << "  }" << std::endl; }

        void operator()(MaroonIRStmt const& code) {
          PrintHeader();
          fo << code.stmt << std::endl;
          PrintFooter();
        }

        void operator()(MaroonIRIf const& cond) {
          size_t const step_idx = nvars.size();
          PrintHeader();
          fo << "      if (" << cond.cond << ") {" << std::endl;
          fo << "        result.branch(IF_YES_" << step_idx << "());" << std::endl;
          fo << "      } else {" << std::endl;
          fo << "        result.branch(IF_NO_" << step_idx << "());" << std::endl;
          fo << "      }" << std::endl;
          PrintFooter();
          // NOTE(dkorolev): On `yes` it will always be the next step index, but that's details.
          fo << "  constexpr static size_t IF_YES_" << step_idx << "() { return " << nvars.size() << "; }" << std::endl;
          cond.yes.Call(*this);

          PrintHeader();
          fo << "      result.branch(IF_DONE_" << step_idx << "());";
          PrintFooter();

          fo << "  constexpr static size_t IF_NO_" << step_idx << "() { return " << nvars.size() << "; }" << std::endl;
          cond.no.Call(*this);
          fo << "  constexpr static size_t IF_DONE_" << step_idx << "() { return " << nvars.size() << "; }"
             << std::endl;
        }

        void operator()(MaroonIRBlock const& blk) {
          size_t const save_local_vars_size = local_vars.size();

          for (auto const& var : blk.vars) {
            next_step_init_vars.push_back(var);
          }

          for (auto const& c : blk.code) {
            c.Call(*this);
          }

          // TODO(dkorolev): Destruction, eventually, of those vars, as they leave the last step of the block.
          if (save_local_vars_size + blk.vars.size() != local_vars.size()) {
            std::cerr << "Internal invariant failed: wrong number of local variables at this point." << std::endl;
            std::exit(1);
          }
          local_vars.resize(local_vars.size() - blk.vars.size());
        }

        void operator()(MaroonIRBlockPlaceholder const&) {
          std::cerr << "Internal invaviant error: seeing `MaroonIRBlockPlaceholder`." << std::endl;
          std::exit(1);
        }
      };

      StatementsRecursiveVisitor visitor(fo);
      for (auto const& [fn_name, fn] : fiber.functions) {
        visitor.EnsureNoLocalVars();
        fo << "    inline constexpr static MaronStateIndex " << fn_name << " = static_cast<MaronStateIndex>("
           << visitor.nvars.size() << ");" << std::endl;
        ;
        visitor.fn_name = fn_name;
        visitor(fn.body);
      }
      fo << "    inline constexpr static uint32_t kStepsCount = " << visitor.nvars.size() << ";" << std::endl;
      fo << "    inline constexpr static std::array<MaroonStep, kStepsCount> kSteps{";
      for (uint32_t i = 0; i < visitor.nvars.size(); ++i) {
        if (i) {
          fo << ",";
        }
        fo << "MaroonStep{IMPL_" << i << ',' << visitor.nvars[i].first << ',' << visitor.nvars[i].second << ",VARS_"
           << i << '}';
      }
      fo << "};" << std::endl;
      fo << "  };  // fiber `" << fiber_name << '`' << std::endl;
    }
    fo << "};  // maroon `" << maroon_name << '`' << std::endl;
  }

  size_t index = 0;
  for (auto const& test : scenarios.tests) {
    fo << std::endl;
    GenerateTestCase(fo, test, FLAGS_name, ++index);
  }
}

// NOTE(dkorolev): This is suboptimal, but it ensures the code builds just with `g++ src.cc`, w/o `-std=c++17`.
#define CURRENT_FOR_CPP14

#include <iostream>
#include <fstream>

#include "../current/bricks/dflags/dflags.h"
#include "../current/bricks/file/file.h"
#include "../current/typesystem/serialization/json.h"

#include "ir.h"

DEFINE_string(in, "", "The input file to parse the JSON of the IR from.");
DEFINE_string(name, "default", "The name to use for the autogenerated tests.");
DEFINE_string(out, "/dev/stdout", "The output file to dump the C++ code into.");

inline void GenerateTestCase(std::ostream& fo, MaroonTestCase const& test, std::string const& name, size_t idx) {
  if (idx == 1) {
    fo << "TEST(Maroon, " << name << ") {" << std::endl;
  } else {
    fo << "TEST(Maroon, " << name << "_" << idx << ") {" << std::endl;
  }
  struct GenerateTestCaseVisitor final {
    std::string const& name;
    std::ostream& fo;
    GenerateTestCaseVisitor(std::string const& name, std::ostream& fo) : name(name), fo(fo) {}
    void operator()(MaroonTestCaseSimple const& test) {
      fo << "  MaroonEngine<" << test.maroon << "> engine;" << std::endl;
      fo << "  auto const [output, error] = engine.run();" << std::endl;
      std::ostringstream oss;
      for (auto const& e : test.debug_statements) {
        // TODO(dkorolev): Handle the timestamps too.
        oss << e.msg << std::endl;
      }
      fo << "  EXPECT_EQ(R\"\"\"(" << oss.str() << ")\"\"\", output);" << std::endl;
      fo << "  EXPECT_EQ(\"\", error);" << std::endl;
    }
    void operator()(MaroonTestCaseShouldThrow const& test) {
      fo << "  MaroonEngine<" << test.maroon << "> engine;" << std::endl;
      fo << "  auto const [output, error] = engine.run();" << std::endl;
      fo << "  EXPECT_EQ(R\"\"\"(" << test.error << ")\"\"\", error);" << std::endl;
      fo << "  EXPECT_EQ(\"\", output);" << std::endl;
    }
  };
  GenerateTestCaseVisitor visitor(name, fo);
  test.Call(visitor);
  fo << '}' << std::endl;
}

constexpr static char const* const kVarsFunctionSignature = "(ImplEnv& env)";
constexpr static char const* const kStepFunctionSignature = "(ImplEnv& env, ImplResultCollector& result)";

int main(int argc, char** argv) {
  ParseDFlags(&argc, &argv);

  if (FLAGS_in.empty()) {
    std::cerr << "The `--in` parameter is required." << std::endl;
    std::exit(1);
  }

  std::ofstream fo(FLAGS_out);

  MaroonIRScenarios scenarios;
  try {
    using T = decltype(scenarios);
    scenarios = ParseJSON<T, JSONFormat::Minimalistic>(current::FileSystem::ReadFileAsString(FLAGS_in));
  } catch (current::Exception const&) {
    std::cerr << "Failed to read and parse the IR JSON from `" << FLAGS_in << "`." << std::endl;
    std::exit(1);
  }

  fo << "#pragma once" << std::endl;
  fo << std::endl;
  fo << "#define CURRENT_FOR_CPP14" << std::endl;
  fo << std::endl;
  fo << "#include \"../src/engine.h\"" << std::endl;

  for (auto const& [maroon_name, maroon] : scenarios.maroon) {
    fo << std::endl;
    fo << "struct " << maroon_name << " {" << std::endl;
    fo << "  constexpr static bool kIsMaroon = true;" << std::endl;
    fo << "  constexpr static char const* const kMaroonName = \"" << maroon_name << "\";" << std::endl;
    for (auto const& [fiber_name, fiber] : maroon.fibers) {
      fo << "  struct " << fiber_name << " {" << std::endl;
      fo << "    constexpr static bool kIsFiber = true;" << std::endl;
      fo << "    constexpr static char const* const kFiberName = \"" << fiber_name << "\";" << std::endl;
      struct StatementsRecursiveVisitor final {
        std::ostream& fo;
        std::vector<std::pair<size_t, size_t>>
            num_vars_per_step;  // { upon entering, to be added before the block starts executing }
        std::string fn_name = "\n#error \"`fn_name` unset.\"\n";
        std::vector<std::string> local_vars;
        std::vector<MaroonIRVar> next_step_init_vars;

        StatementsRecursiveVisitor(std::ostream& fo) : fo(fo) {}

        void EnsureNoLocalVars() {
          if (!local_vars.empty()) {
            std::cerr << "Internal invariant failed: should have no local variables at this point." << std::endl;
            std::exit(1);
          }
        }

        void PrintHeader() {
          size_t const idx = num_vars_per_step.size();
          size_t const save_init_vars_count = next_step_init_vars.size();
          if (local_vars.size() < save_init_vars_count) {
            // TODO(dkorolev): Add a test when blocks are nested and new vars are added between nests in the 1st block.
            std::cerr << "Internal invariant failed: too few local vars." << std::endl;
            std::exit(1);
          }
          fo << "    static void VARS_" << idx << kVarsFunctionSignature << "{ // " << fn_name << std::endl;
          fo << "      static_cast<void>(env);" << std::endl;
          size_t tmp_idx = local_vars.size() - save_init_vars_count;
          for (auto const& var : next_step_init_vars) {
            fo << "      env.DeclareVar(" << tmp_idx++ << ",\"" << var.name << "\"," << var.init << ");" << std::endl;
          }
          next_step_init_vars.clear();
          fo << "    }" << std::endl;
          fo << "    static void IMPL_" << idx << kStepFunctionSignature << " {  // " << fn_name << std::endl;
          num_vars_per_step.push_back({local_vars.size() - save_init_vars_count, save_init_vars_count});
          tmp_idx = 0;
          // TODO(dkorolev): Different var types, not just names here.
          for (auto const& var : local_vars) {
            fo << "      auto& " << var << " = env.AccessVar(" << tmp_idx++ << ",\"" << var << "\");" << std::endl;
            // fo << "  // LOCAL VAR AVAILABLE: " << var << std::endl;
          }
          for (auto const& var : local_vars) {
            fo << "      static_cast<void>(" << var << ");" << std::endl;
          }
        }

        void operator()(MaroonIRNop const&) {
          fo << "#error \"NOP, a.k.a. PASS, this step is empty, which is illegal, need `RETURN()`.\"" << std::endl;
        }
        void operator()(MaroonIRCode const& code) {
          PrintHeader();
          fo << code.code << std::endl << "}" << std::endl;
        }
        void operator()(MaroonIRBlock const& blk) {
          size_t const save_local_vars_size = local_vars.size();

          for (auto const& var : blk.vars) {
            local_vars.push_back(var.name);
            // fo << "  // WILL DECLARE LOCAL VAR " << var.name << std::endl;
          }
          for (auto const& var : blk.vars) {
            next_step_init_vars.push_back(var);
          }

          blk.stmt.Call(*this);

          // TODO(dkorolev): Destruction, eventually, of those vars, as they leave the block (or the function).
          if (save_local_vars_size + blk.vars.size() != local_vars.size()) {
            std::cerr << "Internal invariant failed: wrong number of local variables at this point." << std::endl;
            std::exit(1);
          }
          local_vars.resize(local_vars.size() - blk.vars.size());
        }
        void operator()(MaroonIRSeq const& seq) {
          for (auto const& e : seq.seq) {
            e.Call(*this);
          }
        }
      };
      StatementsRecursiveVisitor visitor(fo);
      for (auto const& [fn_name, fn] : fiber.functions) {
        visitor.EnsureNoLocalVars();
        fo << "    inline constexpr static MaronStateIndex " << fn_name << " = static_cast<MaronStateIndex>("
           << visitor.num_vars_per_step.size() << ");" << std::endl;
        ;
        visitor.fn_name = fn_name;
        fn.Call(visitor);
      }
      fo << "    inline constexpr static uint32_t kStepsCount = " << visitor.num_vars_per_step.size() << ";"
         << std::endl;
      fo << "    inline constexpr static std::array<MaroonStep, kStepsCount> kSteps{";
      for (uint32_t i = 0; i < visitor.num_vars_per_step.size(); ++i) {
        if (i) {
          fo << ",";
        }
        fo << "MaroonStep{IMPL_" << i << ',' << visitor.num_vars_per_step[i].first << ','
           << visitor.num_vars_per_step[i].second << ",VARS_" << i << '}';
      }
      fo << "};" << std::endl;
      fo << "  };  // fiber `" << fiber_name << '`' << std::endl;
    }
    fo << "};  // maroon `" << maroon_name << '`' << std::endl;
  }

  size_t index = 0;
  for (auto const& test : scenarios.tests) {
    fo << std::endl;
    GenerateTestCase(fo, test, FLAGS_name, ++index);
  }
}

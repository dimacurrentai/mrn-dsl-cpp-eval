// NOTE(dkorolev): This is suboptimal, but it ensures the code builds just with `g++ src.cc`, w/o `-std=c++17`.
#define CURRENT_FOR_CPP14

#include <iostream>
#include <fstream>

#include "../current/bricks/dflags/dflags.h"
#include "../current/bricks/file/file.h"
#include "../current/typesystem/serialization/json.h"

#include "ir.h"

DEFINE_string(in, "", "The input file to parse the JSON of the IR from.");
DEFINE_string(name, "default", "The name to use for the autogenerated tests.");
DEFINE_string(out, "/dev/stdout", "The output file to dump the C++ code into.");

inline void GenerateTestCase(std::ostream& fo, MaroonTestCase const& test, std::string const& name, size_t idx) {
  if (idx == 1) {
    fo << "TEST(Maroon, " << name << ") {" << std::endl;
  } else {
    fo << "TEST(Maroon, " << name << "_" << idx << ") {" << std::endl;
  }
  struct GenerateTestCaseVisitor final {
    std::string const& name;
    std::ostream& fo;
    GenerateTestCaseVisitor(std::string const& name, std::ostream& fo) : name(name), fo(fo) {}
    void operator()(MaroonTestCaseRunFiber const& test) {
      fo << "  MaroonEngine<MAROON_NAMESPACE_" << test.maroon << "::MAROON_spec, MAROON_NAMESPACE_" << test.maroon
         << "::" << test.fiber << "> engine;" << std::endl;
      fo << "  auto const output_error = engine.run();" << std::endl;
      std::ostringstream oss;
      for (auto const& e : test.golden_output) {
        oss << e << std::endl;
      }
      fo << "  EXPECT_EQ(R\"\"\"(" << oss.str() << ")\"\"\", output_error.first);" << std::endl;
      fo << "  EXPECT_EQ(\"\", output_error.second);" << std::endl;
    }
    void operator()(MaroonTestCaseFiberShouldThrow const& test) {
      fo << "  MaroonEngine<MAROON_NAMESPACE_" << test.maroon << "::MAROON_spec, MAROON_NAMESPACE_" << test.maroon
         << "::" << test.fiber << "> engine;" << std::endl;
      fo << "  auto const output_error = engine.run();" << std::endl;
      fo << "  EXPECT_EQ(R\"\"\"(" << test.error << ")\"\"\", output_error.second);" << std::endl;
      fo << "  EXPECT_EQ(\"\", output_error.first);" << std::endl;
    }
  };
  GenerateTestCaseVisitor visitor(name, fo);
  test.Call(visitor);
  fo << '}' << std::endl;
}

constexpr static char const* const kVarsFunctionSignature = "(ImplEnv<types_t>& MAROON_env)";
constexpr static char const* const kStepFunctionSignature =
    "(ImplEnv<types_t>& MAROON_env, ImplResultCollector<types_t>& MAROON_result)";

int main(int argc, char** argv) {
  ParseDFlags(&argc, &argv);

  if (FLAGS_in.empty()) {
    std::cerr << "The `--in` parameter is required." << std::endl;
    std::exit(1);
  }

  std::ofstream fo(FLAGS_out);

  MaroonIRScenarios scenarios;
  try {
    using T = decltype(scenarios);
    scenarios = ParseJSON<T, JSONFormat::Minimalistic>(current::FileSystem::ReadFileAsString(FLAGS_in));
  } catch (current::Exception const&) {
    std::cerr << "Failed to read and parse the IR JSON from `" << FLAGS_in << "`." << std::endl;
    std::exit(1);
  }

  fo << "#pragma once" << std::endl;
  fo << std::endl;
  fo << "#define CURRENT_FOR_CPP14" << std::endl;
  fo << std::endl;
  fo << "#include \"../src/engine.h\"" << std::endl;

  for (auto const& iter : scenarios.maroon) {
    auto const& maroon_name = iter.first;
    auto const& maroon = iter.second;
    fo << std::endl;
    fo << "namespace MAROON_NAMESPACE_" << maroon_name << " {" << std::endl;
    std::ostringstream extra_types;
    for (auto const& iter : maroon.types) {
      if (Exists<MaroonIRTypeDefStruct>(iter.second.def)) {
        extra_types << ", MAROON_TYPE_" << iter.first;
        fo << "  CURRENT_STRUCT(MAROON_TYPE_" << iter.first << ") {" << std::endl;
        bool has_fields = false;
        for (auto const& fiter : Value<MaroonIRTypeDefStruct>(iter.second.def).fields) {
          has_fields = true;
          fo << "    CURRENT_FIELD(" << fiter.name << ", MAROON_TYPE_" << fiter.type << ");" << std::endl;
        }
        fo << "    CURRENT_CONSTRUCTOR(MAROON_TYPE_" << iter.first << ")(MaroonLegalInit";
        for (auto const& fiter : Value<MaroonIRTypeDefStruct>(iter.second.def).fields) {
          fo << ", MAROON_TYPE_" << fiter.type << ' ' << fiter.name;
        }
        fo << ')';
        if (has_fields) {
          fo << " : ";
          bool first = true;
          for (auto const& fiter : Value<MaroonIRTypeDefStruct>(iter.second.def).fields) {
            if (first) {
              first = false;
            } else {
              fo << ", ";
            }
            fo << fiter.name << "(std::move(" << fiter.name << "))";
          }
        }
        fo << " {}" << std::endl;
        fo << "  };" << std::endl;
      }
    }
    fo << "  CURRENT_VARIANT(MAROON_NAMESPACE_TYPELIST, MAROON_BASE_TYPES_CSV" << extra_types.str() << ");\n";
    fo << "  struct MAROON_spec final : MaroonDefinition {" << std::endl;
    fo << "    using maroon_namespace_types_t = MAROON_NAMESPACE_TYPELIST;" << std::endl;
    fo << "    char const* const maroon_name() const override { return \"" << maroon_name << "\"; }" << std::endl;
    fo << "  };" << std::endl;
    fo << "  using types_t = typename MAROON_spec::maroon_namespace_types_t;" << std::endl;
    for (auto const& iter : maroon.fibers) {
      auto const& fiber_name = iter.first;
      auto const& fiber = iter.second;
      fo << "  struct " << fiber_name << " {" << std::endl;
      fo << "    constexpr static bool kIsFiber = true;" << std::endl;
      fo << "    constexpr static char const* const kFiberName = \"" << fiber_name << "\";" << std::endl;
      struct StatementsRecursiveVisitor final {
        std::ostream& fo;
        std::vector<std::pair<size_t, size_t>> nvars;  // { # upon entering, # to be added on block entry }
        std::string fn_name = "\n#error \"`fn_name` unset.\"\n";
        std::vector<MaroonIRVar> local_vars;
        std::vector<MaroonIRVar> next_step_init_vars;

        StatementsRecursiveVisitor(std::ostream& fo) : fo(fo) {}

        void EnsureNoLocalVars() {
          if (!local_vars.empty()) {
            std::cerr << "Internal invariant failed: should have no local variables at this point." << std::endl;
            std::exit(1);
          }
        }

        void PrintHeader() {
          size_t const entry_vars = local_vars.size();
          size_t const declared_vars = next_step_init_vars.size();

          size_t const step_idx = nvars.size();
          nvars.push_back({entry_vars, declared_vars});

          // Declare the vars.
          fo << "    static void VARS_" << step_idx << kVarsFunctionSignature << "{ // " << fn_name << std::endl;
          fo << "      static_cast<void>(MAROON_env);" << std::endl;
          for (auto const& var : next_step_init_vars) {
            if (Exists(var.init)) {
              fo << "      MAROON_env.DeclareVar<MAROON_TYPE_" << var.type << ">(" << local_vars.size() << ",\""
                 << var.name << "\", MAROON_TYPE_" << var.type << "(MaroonLegalInit()";
              // TODO(dkorolev): If it does not `Exist`, it's an internal error.
              std::string const init = Value(var.init);
              if (!init.empty()) {
                fo << ", " << init;
              }
              fo << "));" << std::endl;
            } else {
              // TODO(dkorolev): Vars with no `init` are all function arguments, right?
              fo << "      MAROON_env.DeclareFunctionArg<MAROON_TYPE_" << var.type << ">(" << local_vars.size() << ",\""
                 << var.name << "\");" << std::endl;
            }
            local_vars.push_back(var);
          }
          next_step_init_vars.clear();
          fo << "    }" << std::endl;

          fo << "    static void IMPL_" << step_idx << kStepFunctionSignature << " {  // " << fn_name << std::endl;
          size_t tmp_idx = 0;
          // TODO(dkorolev): Different var types, not just names here.
          for (auto const& var : local_vars) {
            fo << "      auto& " << var.name << " = MAROON_env.AccessVar<MAROON_TYPE_" << var.type << ">(" << tmp_idx
               << ",\"" << var.name << "\");\n"
               << "      auto MAROON_VAR_INDEX_" << var.name << " = static_cast<MaroonVarIndex>(" << tmp_idx << ");\n";
            ++tmp_idx;
          }
          // TODO(dkorolev): Put the proper type here.
          fo << "    using T_FUNCTION_RETURN_TYPE = MAROON_TYPE_U64;\n";
          for (auto const& var : local_vars) {
            fo << "      static_cast<void>(" << var.name << ");" << std::endl;
          }
          fo << "      ";
        }

        void PrintFooter() { fo << "  }" << std::endl; }

        void operator()(MaroonIRStmt const& code) {
          PrintHeader();
          // Enable `STMT(...)` without `STMT({...})` for short `STMT`-s.
          fo << code.stmt << std::endl << ';' << std::endl;
          PrintFooter();
        }

        void operator()(MaroonIRIf const& cond) {
          size_t const step_idx = nvars.size();
          PrintHeader();
          fo << "      if (" << cond.cond << ") {" << std::endl;
          fo << "        MAROON_result.branch(IF_YES_" << step_idx << "());" << std::endl;
          fo << "      } else {" << std::endl;
          fo << "        MAROON_result.branch(IF_NO_" << step_idx << "());" << std::endl;
          fo << "      }" << std::endl;
          PrintFooter();
          // NOTE(dkorolev): On `yes` it will always be the next step index, but that's details.
          fo << "  constexpr static MaroonStateIndex IF_YES_" << step_idx
             << "() { return static_cast<MaroonStateIndex>(" << nvars.size() << "); }" << std::endl;
          cond.yes.Call(*this);

          PrintHeader();
          fo << "      MAROON_result.branch(IF_DONE_" << step_idx << "());";
          PrintFooter();

          fo << "  constexpr static MaroonStateIndex IF_NO_" << step_idx << "() { return static_cast<MaroonStateIndex>("
             << nvars.size() << "); }" << std::endl;
          cond.no.Call(*this);
          fo << "  constexpr static MaroonStateIndex IF_DONE_" << step_idx
             << "() { return static_cast<MaroonStateIndex>(" << nvars.size() << "); }" << std::endl;
        }

        void operator()(MaroonIRBlock const& blk) {
          size_t const save_local_vars_size = local_vars.size();

          for (auto const& var : blk.vars) {
            next_step_init_vars.push_back(var);
          }

          for (auto const& c : blk.code) {
            c.Call(*this);
          }

          // TODO(dkorolev): Destruction, eventually, of those vars, as they leave the last step of the block.
          if (save_local_vars_size + blk.vars.size() != local_vars.size()) {
            std::cerr << "Internal invariant failed: wrong number of local variables at this point." << std::endl;
            std::exit(1);
          }
          local_vars.resize(local_vars.size() - blk.vars.size());
        }

        void operator()(MaroonIRBlockPlaceholder const&) {
          std::cerr << "Internal invaviant error: seeing `MaroonIRBlockPlaceholder`." << std::endl;
          std::exit(1);
        }
      };

      for (auto const& iter : fiber.functions) {
        auto const& fn_name = iter.first;
        auto const& fn = iter.second;
        fo << "    using MAROON_F_ARGS_" << fn_name << " = std::tuple<";
        bool first = true;
        for (auto const& a : fn.args) {
          if (first) {
            first = false;
          } else {
            fo << ", ";
          }
          fo << "MAROON_TYPE_" << a;
        }
        fo << ">;\n";
      }

      StatementsRecursiveVisitor visitor(fo);
      for (auto const& iter : fiber.functions) {
        auto const& fn_name = iter.first;
        auto const& fn = iter.second;
        visitor.EnsureNoLocalVars();
        fo << "    constexpr static MaroonStateIndex FN_" << fn_name << " = static_cast<MaroonStateIndex>("
           << visitor.nvars.size() << ");" << std::endl;
        fo << "    constexpr static size_t NUMBER_OF_ARGS_" << fn_name << " = " << fn.args.size() << ";\n";
        visitor.fn_name = fn_name;
        visitor(fn.body);
      }
      fo << "    constexpr static uint32_t kStepsCount = " << visitor.nvars.size() << ";" << std::endl;
      fo << "    static std::array<MaroonStep<types_t>, kStepsCount> MAROON_steps() { return {";
      for (uint32_t i = 0; i < visitor.nvars.size(); ++i) {
        if (i) {
          fo << ",";
        }
        fo << "MaroonStep<types_t>{IMPL_" << i << ',' << visitor.nvars[i].first << ',' << visitor.nvars[i].second
           << ",VARS_" << i << '}';
      }
      fo << "  };" << std::endl;
      fo << "}" << std::endl;
      fo << "  };  // fiber `" << fiber_name << '`' << std::endl;
    }
    fo << "}  // namespace MAROON_NAMESPACE_`" << maroon_name << '`' << std::endl;

    for (auto const& iter : maroon.types) {
      if (Exists<MaroonIRTypeDefStruct>(iter.second.def)) {
        fo << "template <>\n";
        fo << "struct MaroonFormatValueHelperImpl<MAROON_NAMESPACE_" << maroon_name << "::MAROON_TYPE_" << iter.first
           << "> final {\n";
        fo << "  static void DoIt(std::ostream& os, MAROON_NAMESPACE_" << maroon_name << "::MAROON_TYPE_" << iter.first
           << " const& v) {\n";
        fo << "    using namespace MAROON_NAMESPACE_" << maroon_name << ";\n";
        bool first = true;
        fo << "    os << '{';\n";
        for (auto const& fiter : Value<MaroonIRTypeDefStruct>(iter.second.def).fields) {
          if (first) {
            first = false;
          } else {
            fo << "    os << ',';\n";
          }
          fo << "    os << \"" << fiter.name << ":\";\n";
          fo << "    MaroonFormatValueHelperImpl<MAROON_TYPE_" << fiter.type << ">::DoIt(os, v." << fiter.name
             << ");\n";
        }
        fo << "    os << '}';\n";
        fo << "  }\n";
        fo << "};\n";
      }
    }
  }

  size_t index = 0;
  for (auto const& test : scenarios.tests) {
    fo << std::endl;
    GenerateTestCase(fo, test, FLAGS_name, ++index);
  }
}
